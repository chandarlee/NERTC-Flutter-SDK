// Autogenerated from Pigeon (v0.1.17), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import
// @dart = 2.8
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/services.dart';

class IntValue {
  int value;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['value'] = value;
    return pigeonMap;
  }

  // ignore: unused_element
  static IntValue decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return IntValue()
      ..value = pigeonMap['value'] as int;
  }
}

class StartAudioMixingRequest {
  String path;
  int loopCount;
  bool sendEnabled;
  int sendVolume;
  bool playbackEnabled;
  int playbackVolume;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['path'] = path;
    pigeonMap['loopCount'] = loopCount;
    pigeonMap['sendEnabled'] = sendEnabled;
    pigeonMap['sendVolume'] = sendVolume;
    pigeonMap['playbackEnabled'] = playbackEnabled;
    pigeonMap['playbackVolume'] = playbackVolume;
    return pigeonMap;
  }

  // ignore: unused_element
  static StartAudioMixingRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return StartAudioMixingRequest()
      ..path = pigeonMap['path'] as String
      ..loopCount = pigeonMap['loopCount'] as int
      ..sendEnabled = pigeonMap['sendEnabled'] as bool
      ..sendVolume = pigeonMap['sendVolume'] as int
      ..playbackEnabled = pigeonMap['playbackEnabled'] as bool
      ..playbackVolume = pigeonMap['playbackVolume'] as int;
  }
}

class SetVideoRendererMirrorRequest {
  int textureId;
  bool mirror;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['textureId'] = textureId;
    pigeonMap['mirror'] = mirror;
    return pigeonMap;
  }

  // ignore: unused_element
  static SetVideoRendererMirrorRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SetVideoRendererMirrorRequest()
      ..textureId = pigeonMap['textureId'] as int
      ..mirror = pigeonMap['mirror'] as bool;
  }
}

class SetupRemoteVideoRendererRequest {
  int uid;
  int textureId;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['uid'] = uid;
    pigeonMap['textureId'] = textureId;
    return pigeonMap;
  }

  // ignore: unused_element
  static SetupRemoteVideoRendererRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SetupRemoteVideoRendererRequest()
      ..uid = pigeonMap['uid'] as int
      ..textureId = pigeonMap['textureId'] as int;
  }
}

class BoolValue {
  bool value;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['value'] = value;
    return pigeonMap;
  }

  // ignore: unused_element
  static BoolValue decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return BoolValue()
      ..value = pigeonMap['value'] as bool;
  }
}

class DoubleValue {
  double value;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['value'] = value;
    return pigeonMap;
  }

  // ignore: unused_element
  static DoubleValue decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return DoubleValue()
      ..value = pigeonMap['value'] as double;
  }
}

class SetCameraFocusPositionRequest {
  double x;
  double y;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['x'] = x;
    pigeonMap['y'] = y;
    return pigeonMap;
  }

  // ignore: unused_element
  static SetCameraFocusPositionRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SetCameraFocusPositionRequest()
      ..x = pigeonMap['x'] as double
      ..y = pigeonMap['y'] as double;
  }
}

class EnableEarbackRequest {
  bool enabled;
  int volume;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['enabled'] = enabled;
    pigeonMap['volume'] = volume;
    return pigeonMap;
  }

  // ignore: unused_element
  static EnableEarbackRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return EnableEarbackRequest()
      ..enabled = pigeonMap['enabled'] as bool
      ..volume = pigeonMap['volume'] as int;
  }
}

class PlayEffectRequest {
  int effectId;
  String path;
  int loopCount;
  bool sendEnabled;
  int sendVolume;
  bool playbackEnabled;
  int playbackVolume;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['effectId'] = effectId;
    pigeonMap['path'] = path;
    pigeonMap['loopCount'] = loopCount;
    pigeonMap['sendEnabled'] = sendEnabled;
    pigeonMap['sendVolume'] = sendVolume;
    pigeonMap['playbackEnabled'] = playbackEnabled;
    pigeonMap['playbackVolume'] = playbackVolume;
    return pigeonMap;
  }

  // ignore: unused_element
  static PlayEffectRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return PlayEffectRequest()
      ..effectId = pigeonMap['effectId'] as int
      ..path = pigeonMap['path'] as String
      ..loopCount = pigeonMap['loopCount'] as int
      ..sendEnabled = pigeonMap['sendEnabled'] as bool
      ..sendVolume = pigeonMap['sendVolume'] as int
      ..playbackEnabled = pigeonMap['playbackEnabled'] as bool
      ..playbackVolume = pigeonMap['playbackVolume'] as int;
  }
}

class SetEffectSendVolumeRequest {
  int effectId;
  int volume;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['effectId'] = effectId;
    pigeonMap['volume'] = volume;
    return pigeonMap;
  }

  // ignore: unused_element
  static SetEffectSendVolumeRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SetEffectSendVolumeRequest()
      ..effectId = pigeonMap['effectId'] as int
      ..volume = pigeonMap['volume'] as int;
  }
}

class SetEffectPlaybackVolumeRequest {
  int effectId;
  int volume;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['effectId'] = effectId;
    pigeonMap['volume'] = volume;
    return pigeonMap;
  }

  // ignore: unused_element
  static SetEffectPlaybackVolumeRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SetEffectPlaybackVolumeRequest()
      ..effectId = pigeonMap['effectId'] as int
      ..volume = pigeonMap['volume'] as int;
  }
}

class CreateEngineRequest {
  String appKey;
  String logDir;
  int logLevel;
  bool autoSubscribeAudio;
  int videoEncodeMode;
  int videoDecodeMode;
  bool serverRecordAudio;
  bool serverRecordVideo;
  int serverRecordMode;
  bool serverRecordSpeaker;
  bool publishSelfStream;
  bool videoCaptureObserver;
  int videoSendMode;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['appKey'] = appKey;
    pigeonMap['logDir'] = logDir;
    pigeonMap['logLevel'] = logLevel;
    pigeonMap['autoSubscribeAudio'] = autoSubscribeAudio;
    pigeonMap['videoEncodeMode'] = videoEncodeMode;
    pigeonMap['videoDecodeMode'] = videoDecodeMode;
    pigeonMap['serverRecordAudio'] = serverRecordAudio;
    pigeonMap['serverRecordVideo'] = serverRecordVideo;
    pigeonMap['serverRecordMode'] = serverRecordMode;
    pigeonMap['serverRecordSpeaker'] = serverRecordSpeaker;
    pigeonMap['publishSelfStream'] = publishSelfStream;
    pigeonMap['videoCaptureObserver'] = videoCaptureObserver;
    pigeonMap['videoSendMode'] = videoSendMode;
    return pigeonMap;
  }

  // ignore: unused_element
  static CreateEngineRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return CreateEngineRequest()
      ..appKey = pigeonMap['appKey'] as String
      ..logDir = pigeonMap['logDir'] as String
      ..logLevel = pigeonMap['logLevel'] as int
      ..autoSubscribeAudio = pigeonMap['autoSubscribeAudio'] as bool
      ..videoEncodeMode = pigeonMap['videoEncodeMode'] as int
      ..videoDecodeMode = pigeonMap['videoDecodeMode'] as int
      ..serverRecordAudio = pigeonMap['serverRecordAudio'] as bool
      ..serverRecordVideo = pigeonMap['serverRecordVideo'] as bool
      ..serverRecordMode = pigeonMap['serverRecordMode'] as int
      ..serverRecordSpeaker = pigeonMap['serverRecordSpeaker'] as bool
      ..publishSelfStream = pigeonMap['publishSelfStream'] as bool
      ..videoCaptureObserver = pigeonMap['videoCaptureObserver'] as bool
      ..videoSendMode = pigeonMap['videoSendMode'] as int;
  }
}

class JoinChannelRequest {
  String token;
  String channelName;
  int uid;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['token'] = token;
    pigeonMap['channelName'] = channelName;
    pigeonMap['uid'] = uid;
    return pigeonMap;
  }

  // ignore: unused_element
  static JoinChannelRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return JoinChannelRequest()
      ..token = pigeonMap['token'] as String
      ..channelName = pigeonMap['channelName'] as String
      ..uid = pigeonMap['uid'] as int;
  }
}

class SubscribeRemoteAudioStreamRequest {
  int uid;
  bool subscribe;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['uid'] = uid;
    pigeonMap['subscribe'] = subscribe;
    return pigeonMap;
  }

  // ignore: unused_element
  static SubscribeRemoteAudioStreamRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SubscribeRemoteAudioStreamRequest()
      ..uid = pigeonMap['uid'] as int
      ..subscribe = pigeonMap['subscribe'] as bool;
  }
}

class SetAudioProfileRequest {
  int profile;
  int scenario;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['profile'] = profile;
    pigeonMap['scenario'] = scenario;
    return pigeonMap;
  }

  // ignore: unused_element
  static SetAudioProfileRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SetAudioProfileRequest()
      ..profile = pigeonMap['profile'] as int
      ..scenario = pigeonMap['scenario'] as int;
  }
}

class SetLocalVideoConfigRequest {
  int videoProfile;
  int videoCropMode;
  bool frontCamera;
  int frameRate;
  int minFrameRate;
  int bitrate;
  int minBitrate;
  int degradationPrefer;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['videoProfile'] = videoProfile;
    pigeonMap['videoCropMode'] = videoCropMode;
    pigeonMap['frontCamera'] = frontCamera;
    pigeonMap['frameRate'] = frameRate;
    pigeonMap['minFrameRate'] = minFrameRate;
    pigeonMap['bitrate'] = bitrate;
    pigeonMap['minBitrate'] = minBitrate;
    pigeonMap['degradationPrefer'] = degradationPrefer;
    return pigeonMap;
  }

  // ignore: unused_element
  static SetLocalVideoConfigRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SetLocalVideoConfigRequest()
      ..videoProfile = pigeonMap['videoProfile'] as int
      ..videoCropMode = pigeonMap['videoCropMode'] as int
      ..frontCamera = pigeonMap['frontCamera'] as bool
      ..frameRate = pigeonMap['frameRate'] as int
      ..minFrameRate = pigeonMap['minFrameRate'] as int
      ..bitrate = pigeonMap['bitrate'] as int
      ..minBitrate = pigeonMap['minBitrate'] as int
      ..degradationPrefer = pigeonMap['degradationPrefer'] as int;
  }
}

class SubscribeRemoteVideoStreamRequest {
  int uid;
  int streamType;
  bool subscribe;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['uid'] = uid;
    pigeonMap['streamType'] = streamType;
    pigeonMap['subscribe'] = subscribe;
    return pigeonMap;
  }

  // ignore: unused_element
  static SubscribeRemoteVideoStreamRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return SubscribeRemoteVideoStreamRequest()
      ..uid = pigeonMap['uid'] as int
      ..streamType = pigeonMap['streamType'] as int
      ..subscribe = pigeonMap['subscribe'] as bool;
  }
}

class EnableAudioVolumeIndicationRequest {
  bool enable;
  int interval;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['enable'] = enable;
    pigeonMap['interval'] = interval;
    return pigeonMap;
  }

  // ignore: unused_element
  static EnableAudioVolumeIndicationRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return EnableAudioVolumeIndicationRequest()
      ..enable = pigeonMap['enable'] as bool
      ..interval = pigeonMap['interval'] as int;
  }
}

class AddOrUpdateLiveStreamTaskRequest {
  int serial;
  String taskId;
  String url;
  bool serverRecordEnabled;
  int liveMode;
  int layoutWidth;
  int layoutHeight;
  int layoutBackgroundColor;
  String layoutImageUrl;
  int layoutImageX;
  int layoutImageY;
  int layoutImageWidth;
  int layoutImageHeight;
  List<Object> layoutUserTranscodingList;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['serial'] = serial;
    pigeonMap['taskId'] = taskId;
    pigeonMap['url'] = url;
    pigeonMap['serverRecordEnabled'] = serverRecordEnabled;
    pigeonMap['liveMode'] = liveMode;
    pigeonMap['layoutWidth'] = layoutWidth;
    pigeonMap['layoutHeight'] = layoutHeight;
    pigeonMap['layoutBackgroundColor'] = layoutBackgroundColor;
    pigeonMap['layoutImageUrl'] = layoutImageUrl;
    pigeonMap['layoutImageX'] = layoutImageX;
    pigeonMap['layoutImageY'] = layoutImageY;
    pigeonMap['layoutImageWidth'] = layoutImageWidth;
    pigeonMap['layoutImageHeight'] = layoutImageHeight;
    pigeonMap['layoutUserTranscodingList'] = layoutUserTranscodingList;
    return pigeonMap;
  }

  // ignore: unused_element
  static AddOrUpdateLiveStreamTaskRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return AddOrUpdateLiveStreamTaskRequest()
      ..serial = pigeonMap['serial'] as int
      ..taskId = pigeonMap['taskId'] as String
      ..url = pigeonMap['url'] as String
      ..serverRecordEnabled = pigeonMap['serverRecordEnabled'] as bool
      ..liveMode = pigeonMap['liveMode'] as int
      ..layoutWidth = pigeonMap['layoutWidth'] as int
      ..layoutHeight = pigeonMap['layoutHeight'] as int
      ..layoutBackgroundColor = pigeonMap['layoutBackgroundColor'] as int
      ..layoutImageUrl = pigeonMap['layoutImageUrl'] as String
      ..layoutImageX = pigeonMap['layoutImageX'] as int
      ..layoutImageY = pigeonMap['layoutImageY'] as int
      ..layoutImageWidth = pigeonMap['layoutImageWidth'] as int
      ..layoutImageHeight = pigeonMap['layoutImageHeight'] as int
      ..layoutUserTranscodingList = pigeonMap['layoutUserTranscodingList'] as List<Object>;
  }
}

class DeleteLiveStreamTaskRequest {
  int serial;
  String taskId;

  // ignore: unused_element
  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['serial'] = serial;
    pigeonMap['taskId'] = taskId;
    return pigeonMap;
  }

  // ignore: unused_element
  static DeleteLiveStreamTaskRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return DeleteLiveStreamTaskRequest()
      ..serial = pigeonMap['serial'] as int
      ..taskId = pigeonMap['taskId'] as String;
  }
}

class AudioMixingApi {
  Future<IntValue> setAudioMixingEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.setAudioMixingEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> clearAudioMixingEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.clearAudioMixingEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> startAudioMixing(StartAudioMixingRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.startAudioMixing', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> stopAudioMixing() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.stopAudioMixing', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> pauseAudioMixing() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.pauseAudioMixing', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> resumeAudioMixing() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.resumeAudioMixing', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setAudioMixingSendVolume(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.setAudioMixingSendVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> getAudioMixingSendVolume() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.getAudioMixingSendVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setAudioMixingPlaybackVolume(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.setAudioMixingPlaybackVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> getAudioMixingPlaybackVolume() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.getAudioMixingPlaybackVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> getAudioMixingDuration() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.getAudioMixingDuration', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> getAudioMixingCurrentPosition() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.getAudioMixingCurrentPosition', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setAudioMixingPosition(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioMixingApi.setAudioMixingPosition', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }
}

class VideoRendererApi {
  Future<IntValue> createVideoRenderer() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.VideoRendererApi.createVideoRenderer', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setMirror(SetVideoRendererMirrorRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.VideoRendererApi.setMirror', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setupLocalVideoRenderer(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.VideoRendererApi.setupLocalVideoRenderer', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setupRemoteVideoRenderer(SetupRemoteVideoRendererRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.VideoRendererApi.setupRemoteVideoRenderer', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<void> disposeVideoRenderer(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.VideoRendererApi.disposeVideoRenderer', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      // noop
    }
  }
}

class DeviceManagerApi {
  Future<IntValue> setDeviceEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setDeviceEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> clearDeviceEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.clearDeviceEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<BoolValue> isSpeakerphoneOn() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.isSpeakerphoneOn', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return BoolValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setSpeakerphoneOn(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setSpeakerphoneOn', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> switchCamera() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.switchCamera', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setCameraZoomFactor(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setCameraZoomFactor', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<DoubleValue> getCameraMaxZoom() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.getCameraMaxZoom', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return DoubleValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setCameraTorchOn(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setCameraTorchOn', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setCameraFocusPosition(SetCameraFocusPositionRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setCameraFocusPosition', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setPlayoutDeviceMute(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setPlayoutDeviceMute', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<BoolValue> isPlayoutDeviceMute() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.isPlayoutDeviceMute', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return BoolValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setRecordDeviceMute(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setRecordDeviceMute', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<BoolValue> isRecordDeviceMute() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.isRecordDeviceMute', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return BoolValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> enableEarback(EnableEarbackRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.enableEarback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setEarbackVolume(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setEarbackVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setAudioFocusMode(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.DeviceManagerApi.setAudioFocusMode', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }
}

class AudioEffectApi {
  Future<IntValue> setAudioEffectEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.setAudioEffectEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> clearAudioEffectEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.clearAudioEffectEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> playEffect(PlayEffectRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.playEffect', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> stopEffect(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.stopEffect', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> stopAllEffects() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.stopAllEffects', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> pauseEffect(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.pauseEffect', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> resumeEffect(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.resumeEffect', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> pauseAllEffects() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.pauseAllEffects', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> resumeAllEffects() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.resumeAllEffects', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setEffectSendVolume(SetEffectSendVolumeRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.setEffectSendVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> getEffectSendVolume(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.getEffectSendVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setEffectPlaybackVolume(SetEffectPlaybackVolumeRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.setEffectPlaybackVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> getEffectPlaybackVolume(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.AudioEffectApi.getEffectPlaybackVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }
}

class EngineApi {
  Future<IntValue> create(CreateEngineRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.create', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> release() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.release', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setStatsEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.setStatsEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> clearStatsEventCallback() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.clearStatsEventCallback', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setChannelProfile(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.setChannelProfile', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> joinChannel(JoinChannelRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.joinChannel', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> leaveChannel() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.leaveChannel', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> enableLocalAudio(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.enableLocalAudio', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> subscribeRemoteAudioStream(SubscribeRemoteAudioStreamRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.subscribeRemoteAudioStream', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> subscribeAllRemoteAudioStreams(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.subscribeAllRemoteAudioStreams', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setAudioProfile(SetAudioProfileRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.setAudioProfile', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> enableDualStreamMode(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.enableDualStreamMode', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> setLocalVideoConfig(SetLocalVideoConfigRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.setLocalVideoConfig', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> startVideoPreview() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.startVideoPreview', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> stopVideoPreview() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.stopVideoPreview', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> enableLocalVideo(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.enableLocalVideo', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> startScreenCapture(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.startScreenCapture', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> stopScreenCapture() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.stopScreenCapture', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> subscribeRemoteVideoStream(SubscribeRemoteVideoStreamRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.subscribeRemoteVideoStream', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> muteLocalAudioStream(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.muteLocalAudioStream', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> muteLocalVideoStream(BoolValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.muteLocalVideoStream', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> startAudioDump() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.startAudioDump', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> stopAudioDump() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.stopAudioDump', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> enableAudioVolumeIndication(EnableAudioVolumeIndicationRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.enableAudioVolumeIndication', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> adjustRecordingSignalVolume(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.adjustRecordingSignalVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> adjustPlaybackSignalVolume(IntValue arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.adjustPlaybackSignalVolume', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> addLiveStreamTask(AddOrUpdateLiveStreamTaskRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.addLiveStreamTask', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> updateLiveStreamTask(AddOrUpdateLiveStreamTaskRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.updateLiveStreamTask', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }

  Future<IntValue> removeLiveStreamTask(DeleteLiveStreamTaskRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.EngineApi.removeLiveStreamTask', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = replyMap['error'] as Map<Object, Object>;
      throw PlatformException(
        code: error['code'] as String,
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return IntValue.decode(replyMap['result']);
    }
  }
}
